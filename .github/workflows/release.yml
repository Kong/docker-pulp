---
name: release

on:  # yamllint disable-line rule:truthy
  workflow_dispatch:
  push:
    paths-ignore:
    - .github/**
    branches:
    - main
  pull_request:
    paths-ignore:
    - .github/**

env:
  #BUILD_CACHE: ${{ env.GITHUB_WORKSPACE }}/../imagecache # no env. contenxt at top level :/
  BUILD_CACHE: /tmp/imagecache
  CORE_CACHEFILE: pulp_core.tar
  IMAGE_ARTIFACT: pulp_images.tar

jobs:
  build:
    name: Build containers
    runs-on: ubuntu-latest
    env:
      # use per-run tag for build, but consistent tag for cache purposes
      BUILD_TAG: ${{ github.job }}.${{ github.run_id }}
      PRIOR_ART: latest_${{ env.IMAGE_ARTIFACT }}
    outputs:
      tag: ${{ env.BUILD_TAG }}
    steps:
    - uses: actions/checkout@v3.0.0

    # - name: fetch images from latest release
    #   uses: dsaltares/fetch-gh-release-asset@master
    #   with:
    #     file: ${{ env.IMAGE_ARTIFACT }}
    #     token: ${{ secrets.GITHUB_TOKEN }}
    #     target: ${{ env.PRIOR_ART }}
    # - name: Import latest release images
    #   run: |
    #     OUTFILE="$PRIOR_ART"
    #     if [[ -f "$OUTFILE" && -r "$OUTFILE" ]]
    #     then
    #       printf "Importing $OUTFILE\n"
    #       docker load --input "$OUTFILE"
    #     fi
    #     docker images
    #     true

    - name: Build job-specific image
      env:
        DOCKER_BUILDKIT: 1
        ORG: kong
        TAG: ${{ env.BUILD_TAG }}
        IS_PREBUILD: 1
      run: |
        make images
        # make these vars usable in later steps
        for V in ORG TAG
        do
          printf "%s=%s\n" "$V" "${!V}"
        done >> $GITHUB_ENV
    - name: Export images for artifact
      id: artifact_export
      run: |
        docker save --output="$IMAGE_ARTIFACT" $( docker images --format '{{.Repository}}:{{.Tag}}' "$ORG/*:$TAG" )
    - name: Save build artifact
      uses: actions/upload-artifact@v3.0.0
      with:
        name: images
        path: ${{ env.IMAGE_ARTIFACT }}

  release:
    name: Create Github Release
    needs: build
    if: ${{ github.ref == 'refs/heads/main' && ( github.event_name == 'push' || github.event_name == 'workflow_dispatch' ) }}
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.versioning.outputs.version }}
    steps:
    - name: Checkout
      uses: actions/checkout@v3.0.0
      with:
        fetch-depth: 0 # need all refs for tag generation
    - name: Auto Increment Semver Action
      uses: MCKanpolat/auto-semver-action@1.0.7
      id: versioning
      with:
        releaseType: patch
        # this is a read-only action, I think, so either token is ok
        github_token: ${{ secrets.GITHUB_TOKEN }}
    - name: Commit back
      uses: actions-js/push@master
      with:
        # commit back with Github token to avoid retriggering actions
        github_token: ${{ secrets.GITHUB_TOKEN }}
        message: Release ${{ steps.versioning.outputs.version }}
        branch: main
    - name: Create Github Release
      uses: actions/create-release@v1.1.4
      if: steps['versioning']['outputs']['RETURN_STATUS'] == '0'
      env:
        # release with PAT to trigger more actions
        GITHUB_TOKEN: ${{ secrets.ACTION_TOKEN }}
      with:
        tag_name: ${{ steps.versioning.outputs.version }}
        release_name: ${{ steps.versioning.outputs.version }}
        body: Version ${{ steps.versioning.outputs.version }}
        draft: false
        prerelease: false

  publish:
    name: Publish Release
    needs: [build, release]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        tag:
        - ${{ needs.release.outputs.tag }}
        - latest
    steps:
    - uses: actions/checkout@v3.0.0
    - name: Login to DockerHub
      uses: docker/login-action@v1.14.1
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
    - name: Download image artifact
      uses: actions/download-artifact@v3
      with:
        name: images
        path: ${{ env.IMAGE_ARTIFACT }}
    - name: Import image artifact
      run: |
        if [[ -f "$IMAGE_ARTIFACT" && -r "$IMAGE_ARTIFACT" ]]
        then
          docker load --input "$IMAGE_ARTIFACT"
        else
          printf "$IMAGE_ARTIFACT not found? Weird. \n"
          ls -a "$( dirname "$IMAGE_ARTIFACT" )"
        fi
    - name: Build (retag) images
      env:
        DOCKER_BUILDKIT: 1
        ORG: kong
        TAG: ${{ matrix.tag }}
        CACHE_TAG: ${{ needs.build.tag }}
      run: |
        make images
    - name: Publish images
      run: |
        make release
